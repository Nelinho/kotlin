import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar

description = 'Kotlin Full Reflection Library'

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'net.sf.proguard:proguard-gradle:5.2.1'
        classpath 'com.github.jengelman.gradle.plugins:shadow:1.2.4'
    }
}

apply plugin: 'com.github.johnrengelman.shadow'
apply plugin: 'kotlin'

// ---- Shared part -------

static def configureJvmProject(Project project) {
    project.configure(project) {
        task sourcesJar(type: Jar, dependsOn: classes) {
            classifier = 'sources'
            from sourceSets.main.kotlin
        }

        tasks.withType(JavaCompile) {
            sourceCompatibility = 1.6
            targetCompatibility = 1.6
            options.fork = true
            options.forkOptions.executable = "${JDK_16}/bin/javac"
        }

        tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile) {
            kotlinOptions.jdkHome = JDK_16
        }

        test {
            executable = "$JDK_16/bin/java"
        }
    }
}

static def manifestAttributes(Manifest manifest, Project project, String component = null) {
    project.configure(manifest) {
        attributes \
                'Implementation-Vendor': 'JetBrains',
                'Implementation-Title': project.archivesBaseName,
                'Implementation-Version': project.version,
                'Build-Jdk': System.getProperty('java.version')

        if (component != null) {
            attributes \
                'Kotlin-Runtime-Component': component,
                'Kotlin-Version': project.kotlin_language_version
        }
    }
}

static def configurePublishing(Project project) {
    project.configure(project) {
        apply plugin: 'maven'
        apply plugin: 'signing'


        signing {
            required { (project.properties["signingRequired"] ?: project.isSonatypeRelease) }
            sign configurations.archives
        }

        signArchives {
            enabled signing.required
        }

        task dist(type: Copy, dependsOn: assemble) {
            rename "-${java.util.regex.Pattern.quote(version)}", ''
            into distLibDir
        }

        uploadArchives {
            def prepareTask = rootProject.preparePublication
            dependsOn prepareTask

            doFirst {
                repositories.mavenDeployer.repository.url = prepareTask.repoUrl
            }

            repositories {
                mavenDeployer {
                    beforeDeployment { MavenDeployment deployment ->
                        if (signing.required)
                            signing.signPom(deployment)
                    }

                    repository(url: prepareTask.repoUrl) {
                        authentication(userName: prepareTask.username, password: prepareTask.password)
                    }
                    pom.project {
                        name "${project.group}:${project.name}"
                        packaging 'jar'
                        // optionally artifactId can be defined here
                        description project.description
                        url 'https://kotlinlang.org/'
                        licenses {
                            license {
                                name 'The Apache License, Version 2.0'
                                url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                            }
                        }
                        scm {
                            url 'https://github.com/JetBrains/kotlin'
                            connection 'scm:git:https://github.com/JetBrains/kotlin.git'
                            developerConnection 'scm:git:https://github.com/JetBrains/kotlin.git'
                        }
                        developers {
                            developer {
                                name 'Kotlin Team'
                                organization = 'JetBrains'
                                organizationUrl 'https://www.jetbrains.com'
                            }
                        }
                    }
                }
            }
        }

        task publish(dependsOn: uploadArchives)
        task javadocJar(type: Jar) {
            classifier = 'javadoc'
        }
    }

}

def createPreprocessorTask(Project project, def name, def sourceDir, def targetDir, def profile = "JS") {
    project.configure(project) {
        configurations {
            preprocess
        }

        dependencies {
            preprocess "org.jetbrains.kotlin:kotlin-stdlib:${rootProject.ext.kotlinVersion}"
            preprocess "org.jetbrains.kotlin:kotlin-compiler:${rootProject.ext.kotlinVersion}"
        }
    }

    return project.tasks.create("preprocessSources$name", JavaExec) {
        dependsOn ":prepare:compiler:prepare"
        inputs.dir(sourceDir)
        outputs.dir(targetDir)
        classpath = configurations.preprocess
        main = "org.jetbrains.kotlin.preprocessor.PreprocessorCLI"
        args = [sourceDir, targetDir, profile]
        println("preptask cp: " + classpath.asPath)
    }
}


// ---- End of hared part -------

configureJvmProject(project)
configurePublishing(project)


def core = "${rootDir}//core"
def annotationsSrc = "${buildDir}/annotations"
def relocatedCoreSrc = "${buildDir}/core-relocated"

sourceSets {
    main {
        java {
            srcDir annotationsSrc
            srcDir "${core}/descriptor.loader.java/src"
            srcDir "${core}/descriptors/src"
            srcDir "${core}/descriptors.runtime/src"
            srcDir "${core}/deserialization/src"
            srcDir "${core}/util.runtime/src"

            srcDir "${core}/reflection.jvm/src"
        }
    }
}

configurations {
    proguardDeps
    shadows
    compileOnly.extendsFrom(shadows)
}

dependencies {
    proguardDeps project(':kotlin-stdlib')
    shadows 'javax.inject:javax.inject:1'
    shadows project(path: ':custom-dependencies:protobuf-lite')

    compile project(':kotlin-stdlib')
}

task copyAnnotations(type: Sync) {
    // copy just two missing annotations
    from("${core}/runtime.jvm/src") {
        include "**/Mutable.java"
        include "**/ReadOnly.java"
    }
    into(annotationsSrc)
    includeEmptyDirs false
}


compileJava {
    dependsOn copyAnnotations
    // options.compilerArgs.addAll(["-Xlint:unchecked"])
}

compileKotlin {
    dependsOn copyAnnotations
    kotlinOptions {
        freeCompilerArgs = ["-version",
                            "-Xallow-kotlin-package",
                            "-module-name", "kotlin-reflection",
                            "-Xdump-declarations-to", "${buildDir}/reflect-declarations.json"]
    }
}

kotlin.experimental.coroutines "enable"


task reflectShadowJar(type: ShadowJar) {
    classifier = 'shadow'
    version = null
    manifestAttributes(manifest, project, 'Main')

    from (sourceSets.main.output)
    from ("${core}/descriptor.loader.java/src") {
        include 'META-INF/services/**'
    }
    from ("${core}/deserialization/src") {
        include 'META-INF/services/**'
    }

    configurations = [project.configurations.shadows]
    relocate 'org.jetbrains.kotlin', 'kotlin.reflect.jvm.internal.impl'
    relocate 'javax.inject', 'kotlin.reflect.jvm.internal.impl.javax.inject'
    mergeServiceFiles()
}

createScriptTask(project, "stripMetadata") {
    dependsOn reflectShadowJar
    def inputJar = reflectShadowJar.archivePath
    def outputJar = "${libsDir}/kotlin-reflect-stripped.jar"
    inputs.file(inputJar)
    outputs.file(outputJar)
    args += [
            "${rootDir}/generators/infrastructure/strip-kotlin-annotations.kts",
            "kotlin/Metadata",
            "kotlin/reflect/jvm/internal/impl/.*",
            inputJar,
            outputJar
    ]
}

static def createScriptTask(Project project, def name, Closure<JavaExec> configureClosure = null) {
    project.configure(project) {
        configurations {
            scriptCompile
            scriptRuntime.extendsFrom(scriptCompile)
        }

        dependencies {
            scriptCompile "org.jetbrains.kotlin:kotlin-compiler:${rootProject.ext.kotlinVersion}"
            scriptRuntime "org.jetbrains.kotlin:kotlin-script-runtime:${rootProject.ext.kotlinVersion}"
        }
    }

    JavaExec task = project.tasks.create(name, JavaExec)
    return project.configure(task) {
        classpath = project.configurations.scriptCompile
        main = "org.jetbrains.kotlin.cli.jvm.K2JVMCompiler"
        args = [
                "-script",
                "-version",
                "-no-stdlib",
                "-cp", project.configurations.scriptRuntime.asPath]

        if (configureClosure != null) {
            configureClosure.delegate = it
            configureClosure.call()
        }
    }
}

def mainArchiveName = "${archivesBaseName}-${project.version}.jar"
def outputJarPath = "${libsDir}/${mainArchiveName}"
def rtJar = ['jre/lib/rt.jar', '../Classes/classes.jar'].collect { new File(JDK_16, it) }.find { it.isFile() }

task proguard(type: proguard.gradle.ProGuardTask) {
    dependsOn stripMetadata
    inputs.files(stripMetadata.outputs.files)
    outputs.file(outputJarPath)

    injars stripMetadata.outputs.files
    outjars outputJarPath

    libraryjars configurations.proguardDeps.files
    libraryjars rtJar

    configuration "${core}/reflection.jvm/reflection.pro"
}


task relocateCoreSources(type: Copy) {
    def commonPackage = "org/jetbrains/kotlin"

    doFirst {
        delete(relocatedCoreSrc)
    }

    from "${core}/descriptor.loader.java/src/${commonPackage}"
    from "${core}/descriptors/src/${commonPackage}"
    from "${core}/descriptors.runtime/src/${commonPackage}"
    from "${core}/deserialization/src/${commonPackage}"
    from "${core}/util.runtime/src/${commonPackage}"

    into "${relocatedCoreSrc}/kotlin/reflect/jvm/internal/impl"

    doLast {
        ant.replaceregexp(
                match: 'org\\.jetbrains\\.kotlin',
                replace: 'kotlin.reflect.jvm.internal.impl',
                flags: 'g'
        ) {
            fileset(dir: relocatedCoreSrc)
        }
    }
}

jar.enabled false

task relocatedSourcesJar(type: Jar) {
    dependsOn relocateCoreSources
    classifier 'sources'
    from relocatedCoreSrc
    from "${core}/reflection.jvm/src"
}

def artifactJar = [file: file(outputJarPath), builtBy: proguard, name: archivesBaseName]

artifacts {
    runtime artifactJar
    archives artifactJar
    archives relocatedSourcesJar
    archives javadocJar
}

dist {
    from(proguard)
    from(relocatedSourcesJar)
}
